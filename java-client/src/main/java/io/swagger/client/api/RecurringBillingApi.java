/*
 * Qualpay Platform API
 * This document describes the Qualpay Platform API.
 *
 * OpenAPI spec version: 1.1.9
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.swagger.client.api;

import qpPlatform.ApiCallback;
import qpPlatform.ApiClient;
import qpPlatform.ApiException;
import qpPlatform.ApiResponse;
import qpPlatform.Configuration;
import qpPlatform.Pair;
import qpPlatform.ProgressRequestBody;
import qpPlatform.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import io.swagger.client.model.AddRecurringPlanRequest;
import io.swagger.client.model.AddSubscriptionRequest;
import io.swagger.client.model.ArchiveRecurringPlanRequest;
import io.swagger.client.model.CancelSubscriptionRequest;
import io.swagger.client.model.PauseSubscriptionRequest;
import io.swagger.client.model.QPApiResponse;
import io.swagger.client.model.RecurringPlanListResponse;
import io.swagger.client.model.RecurringPlanResponse;
import io.swagger.client.model.ResumeSubscriptionRequest;
import io.swagger.client.model.SubscriptionListResponse;
import io.swagger.client.model.SubscriptionResponse;
import io.swagger.client.model.TransactionListResponse;
import io.swagger.client.model.UpdateRecurringPlanRequest;
import io.swagger.client.model.UpdateSubscriptionRequest;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class RecurringBillingApi {
    private ApiClient apiClient;

    public RecurringBillingApi() {
        this(Configuration.getDefaultApiClient());
    }

    public RecurringBillingApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for addPlan
     * @param body Recurring Plan Object that needs to be added (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call addPlanCall(AddRecurringPlanRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/plan";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call addPlanValidateBeforeCall(AddRecurringPlanRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling addPlan(Async)");
        }
        

        com.squareup.okhttp.Call call = addPlanCall(body, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Add a Recurring Plan
     * Adds a new Recurring Plan. Save the generated unique plan_id, which is required to delete a plan. 
     * @param body Recurring Plan Object that needs to be added (required)
     * @return RecurringPlanResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public RecurringPlanResponse addPlan(AddRecurringPlanRequest body) throws ApiException {
        ApiResponse<RecurringPlanResponse> resp = addPlanWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Add a Recurring Plan
     * Adds a new Recurring Plan. Save the generated unique plan_id, which is required to delete a plan. 
     * @param body Recurring Plan Object that needs to be added (required)
     * @return ApiResponse&lt;RecurringPlanResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<RecurringPlanResponse> addPlanWithHttpInfo(AddRecurringPlanRequest body) throws ApiException {
        com.squareup.okhttp.Call call = addPlanValidateBeforeCall(body, null, null);
        Type localVarReturnType = new TypeToken<RecurringPlanResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Add a Recurring Plan (asynchronously)
     * Adds a new Recurring Plan. Save the generated unique plan_id, which is required to delete a plan. 
     * @param body Recurring Plan Object that needs to be added (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call addPlanAsync(AddRecurringPlanRequest body, final ApiCallback<RecurringPlanResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = addPlanValidateBeforeCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<RecurringPlanResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for addSubscription
     * @param body Subscription Request (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call addSubscriptionCall(AddSubscriptionRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/subscription";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call addSubscriptionValidateBeforeCall(AddSubscriptionRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        

        com.squareup.okhttp.Call call = addSubscriptionCall(body, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Add a Subscription
     * Creates a new subscription on the specified start date. Returns the subscription_id; save this id to interact with this subscription using the API. When a subscription is added, with a one-time fee, a payment gateway sale request is  made immediately to bill the customer the one-time fee. Check the response in the return model to check the status of the payment gateway request. Note that the subscription remains active even if the payment gateway request for the one-time fee fails. An “off plan” subscription, a subscription without a plan, can be created by excluding the plan_code from your request and sending applicable fields
     * @param body Subscription Request (optional)
     * @return SubscriptionResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public SubscriptionResponse addSubscription(AddSubscriptionRequest body) throws ApiException {
        ApiResponse<SubscriptionResponse> resp = addSubscriptionWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Add a Subscription
     * Creates a new subscription on the specified start date. Returns the subscription_id; save this id to interact with this subscription using the API. When a subscription is added, with a one-time fee, a payment gateway sale request is  made immediately to bill the customer the one-time fee. Check the response in the return model to check the status of the payment gateway request. Note that the subscription remains active even if the payment gateway request for the one-time fee fails. An “off plan” subscription, a subscription without a plan, can be created by excluding the plan_code from your request and sending applicable fields
     * @param body Subscription Request (optional)
     * @return ApiResponse&lt;SubscriptionResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<SubscriptionResponse> addSubscriptionWithHttpInfo(AddSubscriptionRequest body) throws ApiException {
        com.squareup.okhttp.Call call = addSubscriptionValidateBeforeCall(body, null, null);
        Type localVarReturnType = new TypeToken<SubscriptionResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Add a Subscription (asynchronously)
     * Creates a new subscription on the specified start date. Returns the subscription_id; save this id to interact with this subscription using the API. When a subscription is added, with a one-time fee, a payment gateway sale request is  made immediately to bill the customer the one-time fee. Check the response in the return model to check the status of the payment gateway request. Note that the subscription remains active even if the payment gateway request for the one-time fee fails. An “off plan” subscription, a subscription without a plan, can be created by excluding the plan_code from your request and sending applicable fields
     * @param body Subscription Request (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call addSubscriptionAsync(AddSubscriptionRequest body, final ApiCallback<SubscriptionResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = addSubscriptionValidateBeforeCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<SubscriptionResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for archivePlan
     * @param planCode Plan Code that will be archived (required)
     * @param body Plan Name (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call archivePlanCall(String planCode, ArchiveRecurringPlanRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/plan/{plan_code}/archive"
            .replaceAll("\\{" + "plan_code" + "\\}", apiClient.escapeString(planCode.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call archivePlanValidateBeforeCall(String planCode, ArchiveRecurringPlanRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'planCode' is set
        if (planCode == null) {
            throw new ApiException("Missing the required parameter 'planCode' when calling archivePlan(Async)");
        }
        

        com.squareup.okhttp.Call call = archivePlanCall(planCode, body, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Archive a Recurring Plan
     * Archives a Plan. Only active plans can be archived. Note that if there are subscribers to this plan, then all subscriptions belonging to this plan will continue to be active. No updates can be made to an archived plan. New subscribers cannot be added to a archived plan. You can always pull up information on an archived plan from the system. 
     * @param planCode Plan Code that will be archived (required)
     * @param body Plan Name (optional)
     * @return RecurringPlanResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public RecurringPlanResponse archivePlan(String planCode, ArchiveRecurringPlanRequest body) throws ApiException {
        ApiResponse<RecurringPlanResponse> resp = archivePlanWithHttpInfo(planCode, body);
        return resp.getData();
    }

    /**
     * Archive a Recurring Plan
     * Archives a Plan. Only active plans can be archived. Note that if there are subscribers to this plan, then all subscriptions belonging to this plan will continue to be active. No updates can be made to an archived plan. New subscribers cannot be added to a archived plan. You can always pull up information on an archived plan from the system. 
     * @param planCode Plan Code that will be archived (required)
     * @param body Plan Name (optional)
     * @return ApiResponse&lt;RecurringPlanResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<RecurringPlanResponse> archivePlanWithHttpInfo(String planCode, ArchiveRecurringPlanRequest body) throws ApiException {
        com.squareup.okhttp.Call call = archivePlanValidateBeforeCall(planCode, body, null, null);
        Type localVarReturnType = new TypeToken<RecurringPlanResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Archive a Recurring Plan (asynchronously)
     * Archives a Plan. Only active plans can be archived. Note that if there are subscribers to this plan, then all subscriptions belonging to this plan will continue to be active. No updates can be made to an archived plan. New subscribers cannot be added to a archived plan. You can always pull up information on an archived plan from the system. 
     * @param planCode Plan Code that will be archived (required)
     * @param body Plan Name (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call archivePlanAsync(String planCode, ArchiveRecurringPlanRequest body, final ApiCallback<RecurringPlanResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = archivePlanValidateBeforeCall(planCode, body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<RecurringPlanResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for browsePlans
     * @param count The number of records in the result. (optional, default to 10)
     * @param orderOn The field on which the results will be sorted on. Refer to the response model for available fields. (optional, default to plan_code)
     * @param orderBy Ascending or Descending Sort order of the result. Possible values are: asc (Ascending sort order), desc (Descending sort order) (optional, default to asc)
     * @param page Zero-based page number, use this to choose a page when there are more results than the count parameter. (optional, default to 0)
     * @param filter Results can be filtered by custom filter criteria. Refer to [Filter](/developer/api/reference#filters) to use the filter parameter. (optional)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call browsePlansCall(Integer count, String orderOn, String orderBy, Integer page, String filter, Long merchantId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/plan";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (count != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("count", count));
        if (orderOn != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("order_on", orderOn));
        if (orderBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("order_by", orderBy));
        if (page != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
        if (filter != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("filter", filter));
        if (merchantId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("merchant_id", merchantId));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call browsePlansValidateBeforeCall(Integer count, String orderOn, String orderBy, Integer page, String filter, Long merchantId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        

        com.squareup.okhttp.Call call = browsePlansCall(count, orderOn, orderBy, page, filter, merchantId, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get all Recurring Plans
     * Gets a paginated list of recurring plans. Optional query parameters determines, size and sort order of returned array
     * @param count The number of records in the result. (optional, default to 10)
     * @param orderOn The field on which the results will be sorted on. Refer to the response model for available fields. (optional, default to plan_code)
     * @param orderBy Ascending or Descending Sort order of the result. Possible values are: asc (Ascending sort order), desc (Descending sort order) (optional, default to asc)
     * @param page Zero-based page number, use this to choose a page when there are more results than the count parameter. (optional, default to 0)
     * @param filter Results can be filtered by custom filter criteria. Refer to [Filter](/developer/api/reference#filters) to use the filter parameter. (optional)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @return RecurringPlanListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public RecurringPlanListResponse browsePlans(Integer count, String orderOn, String orderBy, Integer page, String filter, Long merchantId) throws ApiException {
        ApiResponse<RecurringPlanListResponse> resp = browsePlansWithHttpInfo(count, orderOn, orderBy, page, filter, merchantId);
        return resp.getData();
    }

    /**
     * Get all Recurring Plans
     * Gets a paginated list of recurring plans. Optional query parameters determines, size and sort order of returned array
     * @param count The number of records in the result. (optional, default to 10)
     * @param orderOn The field on which the results will be sorted on. Refer to the response model for available fields. (optional, default to plan_code)
     * @param orderBy Ascending or Descending Sort order of the result. Possible values are: asc (Ascending sort order), desc (Descending sort order) (optional, default to asc)
     * @param page Zero-based page number, use this to choose a page when there are more results than the count parameter. (optional, default to 0)
     * @param filter Results can be filtered by custom filter criteria. Refer to [Filter](/developer/api/reference#filters) to use the filter parameter. (optional)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @return ApiResponse&lt;RecurringPlanListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<RecurringPlanListResponse> browsePlansWithHttpInfo(Integer count, String orderOn, String orderBy, Integer page, String filter, Long merchantId) throws ApiException {
        com.squareup.okhttp.Call call = browsePlansValidateBeforeCall(count, orderOn, orderBy, page, filter, merchantId, null, null);
        Type localVarReturnType = new TypeToken<RecurringPlanListResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get all Recurring Plans (asynchronously)
     * Gets a paginated list of recurring plans. Optional query parameters determines, size and sort order of returned array
     * @param count The number of records in the result. (optional, default to 10)
     * @param orderOn The field on which the results will be sorted on. Refer to the response model for available fields. (optional, default to plan_code)
     * @param orderBy Ascending or Descending Sort order of the result. Possible values are: asc (Ascending sort order), desc (Descending sort order) (optional, default to asc)
     * @param page Zero-based page number, use this to choose a page when there are more results than the count parameter. (optional, default to 0)
     * @param filter Results can be filtered by custom filter criteria. Refer to [Filter](/developer/api/reference#filters) to use the filter parameter. (optional)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call browsePlansAsync(Integer count, String orderOn, String orderBy, Integer page, String filter, Long merchantId, final ApiCallback<RecurringPlanListResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = browsePlansValidateBeforeCall(count, orderOn, orderBy, page, filter, merchantId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<RecurringPlanListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for browseSubscriptions
     * @param count The number of records in the result. (optional, default to 10)
     * @param orderOn The field on which the results will be sorted on. Refer to the response model for available fields. (optional, default to date_next)
     * @param orderBy Ascending or Descending Sort order of the result. Possible values are: asc (Ascending sort order), desc (Descending sort order) (optional, default to desc)
     * @param page Zero-based page number, use this to choose a page when there are more results than the count parameter. (optional, default to 0)
     * @param filter Results can be filtered by custom filter criteria. Refer to [Filter](/developer/api/reference#filters) to use the filter parameter. (optional)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call browseSubscriptionsCall(Integer count, String orderOn, String orderBy, Integer page, String filter, Long merchantId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/subscription";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (count != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("count", count));
        if (orderOn != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("order_on", orderOn));
        if (orderBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("order_by", orderBy));
        if (page != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
        if (filter != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("filter", filter));
        if (merchantId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("merchant_id", merchantId));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call browseSubscriptionsValidateBeforeCall(Integer count, String orderOn, String orderBy, Integer page, String filter, Long merchantId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        

        com.squareup.okhttp.Call call = browseSubscriptionsCall(count, orderOn, orderBy, page, filter, merchantId, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get all Subscriptions
     * Gets an array of subscription objects. Optional query parameters determines, size and sort order of returned array
     * @param count The number of records in the result. (optional, default to 10)
     * @param orderOn The field on which the results will be sorted on. Refer to the response model for available fields. (optional, default to date_next)
     * @param orderBy Ascending or Descending Sort order of the result. Possible values are: asc (Ascending sort order), desc (Descending sort order) (optional, default to desc)
     * @param page Zero-based page number, use this to choose a page when there are more results than the count parameter. (optional, default to 0)
     * @param filter Results can be filtered by custom filter criteria. Refer to [Filter](/developer/api/reference#filters) to use the filter parameter. (optional)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @return SubscriptionListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public SubscriptionListResponse browseSubscriptions(Integer count, String orderOn, String orderBy, Integer page, String filter, Long merchantId) throws ApiException {
        ApiResponse<SubscriptionListResponse> resp = browseSubscriptionsWithHttpInfo(count, orderOn, orderBy, page, filter, merchantId);
        return resp.getData();
    }

    /**
     * Get all Subscriptions
     * Gets an array of subscription objects. Optional query parameters determines, size and sort order of returned array
     * @param count The number of records in the result. (optional, default to 10)
     * @param orderOn The field on which the results will be sorted on. Refer to the response model for available fields. (optional, default to date_next)
     * @param orderBy Ascending or Descending Sort order of the result. Possible values are: asc (Ascending sort order), desc (Descending sort order) (optional, default to desc)
     * @param page Zero-based page number, use this to choose a page when there are more results than the count parameter. (optional, default to 0)
     * @param filter Results can be filtered by custom filter criteria. Refer to [Filter](/developer/api/reference#filters) to use the filter parameter. (optional)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @return ApiResponse&lt;SubscriptionListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<SubscriptionListResponse> browseSubscriptionsWithHttpInfo(Integer count, String orderOn, String orderBy, Integer page, String filter, Long merchantId) throws ApiException {
        com.squareup.okhttp.Call call = browseSubscriptionsValidateBeforeCall(count, orderOn, orderBy, page, filter, merchantId, null, null);
        Type localVarReturnType = new TypeToken<SubscriptionListResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get all Subscriptions (asynchronously)
     * Gets an array of subscription objects. Optional query parameters determines, size and sort order of returned array
     * @param count The number of records in the result. (optional, default to 10)
     * @param orderOn The field on which the results will be sorted on. Refer to the response model for available fields. (optional, default to date_next)
     * @param orderBy Ascending or Descending Sort order of the result. Possible values are: asc (Ascending sort order), desc (Descending sort order) (optional, default to desc)
     * @param page Zero-based page number, use this to choose a page when there are more results than the count parameter. (optional, default to 0)
     * @param filter Results can be filtered by custom filter criteria. Refer to [Filter](/developer/api/reference#filters) to use the filter parameter. (optional)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call browseSubscriptionsAsync(Integer count, String orderOn, String orderBy, Integer page, String filter, Long merchantId, final ApiCallback<SubscriptionListResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = browseSubscriptionsValidateBeforeCall(count, orderOn, orderBy, page, filter, merchantId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<SubscriptionListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for cancelSubscription
     * @param subscriptionId Subscription ID (required)
     * @param body Customer ID (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call cancelSubscriptionCall(Long subscriptionId, CancelSubscriptionRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/subscription/{subscription_id}/cancel"
            .replaceAll("\\{" + "subscription_id" + "\\}", apiClient.escapeString(subscriptionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call cancelSubscriptionValidateBeforeCall(Long subscriptionId, CancelSubscriptionRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'subscriptionId' is set
        if (subscriptionId == null) {
            throw new ApiException("Missing the required parameter 'subscriptionId' when calling cancelSubscription(Async)");
        }
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling cancelSubscription(Async)");
        }
        

        com.squareup.okhttp.Call call = cancelSubscriptionCall(subscriptionId, body, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Cancel a Subscription
     * Cancels a subscription. Only active, suspended or paused subscriptions can be cancelled. A cancelled subscription cannot be resumed. 
     * @param subscriptionId Subscription ID (required)
     * @param body Customer ID (required)
     * @return SubscriptionResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public SubscriptionResponse cancelSubscription(Long subscriptionId, CancelSubscriptionRequest body) throws ApiException {
        ApiResponse<SubscriptionResponse> resp = cancelSubscriptionWithHttpInfo(subscriptionId, body);
        return resp.getData();
    }

    /**
     * Cancel a Subscription
     * Cancels a subscription. Only active, suspended or paused subscriptions can be cancelled. A cancelled subscription cannot be resumed. 
     * @param subscriptionId Subscription ID (required)
     * @param body Customer ID (required)
     * @return ApiResponse&lt;SubscriptionResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<SubscriptionResponse> cancelSubscriptionWithHttpInfo(Long subscriptionId, CancelSubscriptionRequest body) throws ApiException {
        com.squareup.okhttp.Call call = cancelSubscriptionValidateBeforeCall(subscriptionId, body, null, null);
        Type localVarReturnType = new TypeToken<SubscriptionResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Cancel a Subscription (asynchronously)
     * Cancels a subscription. Only active, suspended or paused subscriptions can be cancelled. A cancelled subscription cannot be resumed. 
     * @param subscriptionId Subscription ID (required)
     * @param body Customer ID (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call cancelSubscriptionAsync(Long subscriptionId, CancelSubscriptionRequest body, final ApiCallback<SubscriptionResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = cancelSubscriptionValidateBeforeCall(subscriptionId, body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<SubscriptionResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for deletePlan
     * @param planId Plan ID that will flagged as deleted (required)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call deletePlanCall(Long planId, Long merchantId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/plan/{plan_id}/delete"
            .replaceAll("\\{" + "plan_id" + "\\}", apiClient.escapeString(planId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (merchantId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("merchant_id", merchantId));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call deletePlanValidateBeforeCall(Long planId, Long merchantId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'planId' is set
        if (planId == null) {
            throw new ApiException("Missing the required parameter 'planId' when calling deletePlan(Async)");
        }
        

        com.squareup.okhttp.Call call = deletePlanCall(planId, merchantId, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Delete a Recurring Plan
     * Deletes a Plan. Any plan, active or not can be deleted. If there are subscribers to the plan, then all subscriptions related to this plan will be cancelled. A deleted plan cannot be updated, neither can new subscrbers be added to a deleted plan. Even if a plan is deleted, you can query the system to get information about the deleted plan. 
     * @param planId Plan ID that will flagged as deleted (required)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @return RecurringPlanResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public RecurringPlanResponse deletePlan(Long planId, Long merchantId) throws ApiException {
        ApiResponse<RecurringPlanResponse> resp = deletePlanWithHttpInfo(planId, merchantId);
        return resp.getData();
    }

    /**
     * Delete a Recurring Plan
     * Deletes a Plan. Any plan, active or not can be deleted. If there are subscribers to the plan, then all subscriptions related to this plan will be cancelled. A deleted plan cannot be updated, neither can new subscrbers be added to a deleted plan. Even if a plan is deleted, you can query the system to get information about the deleted plan. 
     * @param planId Plan ID that will flagged as deleted (required)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @return ApiResponse&lt;RecurringPlanResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<RecurringPlanResponse> deletePlanWithHttpInfo(Long planId, Long merchantId) throws ApiException {
        com.squareup.okhttp.Call call = deletePlanValidateBeforeCall(planId, merchantId, null, null);
        Type localVarReturnType = new TypeToken<RecurringPlanResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Delete a Recurring Plan (asynchronously)
     * Deletes a Plan. Any plan, active or not can be deleted. If there are subscribers to the plan, then all subscriptions related to this plan will be cancelled. A deleted plan cannot be updated, neither can new subscrbers be added to a deleted plan. Even if a plan is deleted, you can query the system to get information about the deleted plan. 
     * @param planId Plan ID that will flagged as deleted (required)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call deletePlanAsync(Long planId, Long merchantId, final ApiCallback<RecurringPlanResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = deletePlanValidateBeforeCall(planId, merchantId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<RecurringPlanResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getAllSubscriptionTransactions
     * @param count The number of records in the result. (optional, default to 10)
     * @param orderOn The field on which the results will be sorted on. Refer to the response model for available fields. (optional, default to tran_time)
     * @param orderBy Ascending or Descending Sort order of the result. Possible values are: asc (Ascending sort order), desc (Descending sort order) (optional, default to desc)
     * @param page Zero-based page number, use this to choose a page when there are more results than the count parameter. (optional, default to 0)
     * @param filter Results can be filtered by custom filter criteria. Refer to [Filter](/developer/api/reference#filters) to use the filter parameter. (optional)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getAllSubscriptionTransactionsCall(Integer count, String orderOn, String orderBy, Integer page, String filter, Long merchantId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/subscription/transactions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (count != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("count", count));
        if (orderOn != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("order_on", orderOn));
        if (orderBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("order_by", orderBy));
        if (page != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
        if (filter != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("filter", filter));
        if (merchantId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("merchant_id", merchantId));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getAllSubscriptionTransactionsValidateBeforeCall(Integer count, String orderOn, String orderBy, Integer page, String filter, Long merchantId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        

        com.squareup.okhttp.Call call = getAllSubscriptionTransactionsCall(count, orderOn, orderBy, page, filter, merchantId, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get all subscription transactions
     * Gets all subscription transactions. Optional Parameters will help filter and restrict the result. 
     * @param count The number of records in the result. (optional, default to 10)
     * @param orderOn The field on which the results will be sorted on. Refer to the response model for available fields. (optional, default to tran_time)
     * @param orderBy Ascending or Descending Sort order of the result. Possible values are: asc (Ascending sort order), desc (Descending sort order) (optional, default to desc)
     * @param page Zero-based page number, use this to choose a page when there are more results than the count parameter. (optional, default to 0)
     * @param filter Results can be filtered by custom filter criteria. Refer to [Filter](/developer/api/reference#filters) to use the filter parameter. (optional)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @return TransactionListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public TransactionListResponse getAllSubscriptionTransactions(Integer count, String orderOn, String orderBy, Integer page, String filter, Long merchantId) throws ApiException {
        ApiResponse<TransactionListResponse> resp = getAllSubscriptionTransactionsWithHttpInfo(count, orderOn, orderBy, page, filter, merchantId);
        return resp.getData();
    }

    /**
     * Get all subscription transactions
     * Gets all subscription transactions. Optional Parameters will help filter and restrict the result. 
     * @param count The number of records in the result. (optional, default to 10)
     * @param orderOn The field on which the results will be sorted on. Refer to the response model for available fields. (optional, default to tran_time)
     * @param orderBy Ascending or Descending Sort order of the result. Possible values are: asc (Ascending sort order), desc (Descending sort order) (optional, default to desc)
     * @param page Zero-based page number, use this to choose a page when there are more results than the count parameter. (optional, default to 0)
     * @param filter Results can be filtered by custom filter criteria. Refer to [Filter](/developer/api/reference#filters) to use the filter parameter. (optional)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @return ApiResponse&lt;TransactionListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<TransactionListResponse> getAllSubscriptionTransactionsWithHttpInfo(Integer count, String orderOn, String orderBy, Integer page, String filter, Long merchantId) throws ApiException {
        com.squareup.okhttp.Call call = getAllSubscriptionTransactionsValidateBeforeCall(count, orderOn, orderBy, page, filter, merchantId, null, null);
        Type localVarReturnType = new TypeToken<TransactionListResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get all subscription transactions (asynchronously)
     * Gets all subscription transactions. Optional Parameters will help filter and restrict the result. 
     * @param count The number of records in the result. (optional, default to 10)
     * @param orderOn The field on which the results will be sorted on. Refer to the response model for available fields. (optional, default to tran_time)
     * @param orderBy Ascending or Descending Sort order of the result. Possible values are: asc (Ascending sort order), desc (Descending sort order) (optional, default to desc)
     * @param page Zero-based page number, use this to choose a page when there are more results than the count parameter. (optional, default to 0)
     * @param filter Results can be filtered by custom filter criteria. Refer to [Filter](/developer/api/reference#filters) to use the filter parameter. (optional)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getAllSubscriptionTransactionsAsync(Integer count, String orderOn, String orderBy, Integer page, String filter, Long merchantId, final ApiCallback<TransactionListResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getAllSubscriptionTransactionsValidateBeforeCall(count, orderOn, orderBy, page, filter, merchantId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<TransactionListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getPlan
     * @param planCode Plan Code (required)
     * @param count The number of records in the result. (optional, default to 10)
     * @param orderOn The field on which the results will be sorted on. Refer to the response model for available fields. (optional, default to plan_code)
     * @param orderBy Ascending or Descending Sort order of the result. Possible values are: asc (Ascending sort order), desc (Descending sort order) (optional, default to asc)
     * @param page Zero-based page number, use this to choose a page when there are more results than the count parameter. (optional, default to 0)
     * @param filter Results can be filtered by custom filter criteria. Refer to [Filter](/developer/api/reference#filters) to use the filter parameter. (optional)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getPlanCall(String planCode, Integer count, String orderOn, String orderBy, Integer page, String filter, Long merchantId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/plan/{plan_code}"
            .replaceAll("\\{" + "plan_code" + "\\}", apiClient.escapeString(planCode.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (count != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("count", count));
        if (orderOn != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("order_on", orderOn));
        if (orderBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("order_by", orderBy));
        if (page != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
        if (filter != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("filter", filter));
        if (merchantId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("merchant_id", merchantId));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getPlanValidateBeforeCall(String planCode, Integer count, String orderOn, String orderBy, Integer page, String filter, Long merchantId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'planCode' is set
        if (planCode == null) {
            throw new ApiException("Missing the required parameter 'planCode' when calling getPlan(Async)");
        }
        

        com.squareup.okhttp.Call call = getPlanCall(planCode, count, orderOn, orderBy, page, filter, merchantId, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Find Recurring Plan by Plan Code
     * Returns a list of recurring plans for the plan_code. Search result includes active, archived and deleted plans. Optional query parameters determines, size and sort order of returned array
     * @param planCode Plan Code (required)
     * @param count The number of records in the result. (optional, default to 10)
     * @param orderOn The field on which the results will be sorted on. Refer to the response model for available fields. (optional, default to plan_code)
     * @param orderBy Ascending or Descending Sort order of the result. Possible values are: asc (Ascending sort order), desc (Descending sort order) (optional, default to asc)
     * @param page Zero-based page number, use this to choose a page when there are more results than the count parameter. (optional, default to 0)
     * @param filter Results can be filtered by custom filter criteria. Refer to [Filter](/developer/api/reference#filters) to use the filter parameter. (optional)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @return RecurringPlanListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public RecurringPlanListResponse getPlan(String planCode, Integer count, String orderOn, String orderBy, Integer page, String filter, Long merchantId) throws ApiException {
        ApiResponse<RecurringPlanListResponse> resp = getPlanWithHttpInfo(planCode, count, orderOn, orderBy, page, filter, merchantId);
        return resp.getData();
    }

    /**
     * Find Recurring Plan by Plan Code
     * Returns a list of recurring plans for the plan_code. Search result includes active, archived and deleted plans. Optional query parameters determines, size and sort order of returned array
     * @param planCode Plan Code (required)
     * @param count The number of records in the result. (optional, default to 10)
     * @param orderOn The field on which the results will be sorted on. Refer to the response model for available fields. (optional, default to plan_code)
     * @param orderBy Ascending or Descending Sort order of the result. Possible values are: asc (Ascending sort order), desc (Descending sort order) (optional, default to asc)
     * @param page Zero-based page number, use this to choose a page when there are more results than the count parameter. (optional, default to 0)
     * @param filter Results can be filtered by custom filter criteria. Refer to [Filter](/developer/api/reference#filters) to use the filter parameter. (optional)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @return ApiResponse&lt;RecurringPlanListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<RecurringPlanListResponse> getPlanWithHttpInfo(String planCode, Integer count, String orderOn, String orderBy, Integer page, String filter, Long merchantId) throws ApiException {
        com.squareup.okhttp.Call call = getPlanValidateBeforeCall(planCode, count, orderOn, orderBy, page, filter, merchantId, null, null);
        Type localVarReturnType = new TypeToken<RecurringPlanListResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Find Recurring Plan by Plan Code (asynchronously)
     * Returns a list of recurring plans for the plan_code. Search result includes active, archived and deleted plans. Optional query parameters determines, size and sort order of returned array
     * @param planCode Plan Code (required)
     * @param count The number of records in the result. (optional, default to 10)
     * @param orderOn The field on which the results will be sorted on. Refer to the response model for available fields. (optional, default to plan_code)
     * @param orderBy Ascending or Descending Sort order of the result. Possible values are: asc (Ascending sort order), desc (Descending sort order) (optional, default to asc)
     * @param page Zero-based page number, use this to choose a page when there are more results than the count parameter. (optional, default to 0)
     * @param filter Results can be filtered by custom filter criteria. Refer to [Filter](/developer/api/reference#filters) to use the filter parameter. (optional)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getPlanAsync(String planCode, Integer count, String orderOn, String orderBy, Integer page, String filter, Long merchantId, final ApiCallback<RecurringPlanListResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getPlanValidateBeforeCall(planCode, count, orderOn, orderBy, page, filter, merchantId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<RecurringPlanListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getSubscription
     * @param subscriptionId Subscription ID (required)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getSubscriptionCall(Long subscriptionId, Long merchantId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/subscription/{subscription_id}"
            .replaceAll("\\{" + "subscription_id" + "\\}", apiClient.escapeString(subscriptionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (merchantId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("merchant_id", merchantId));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getSubscriptionValidateBeforeCall(Long subscriptionId, Long merchantId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'subscriptionId' is set
        if (subscriptionId == null) {
            throw new ApiException("Missing the required parameter 'subscriptionId' when calling getSubscription(Async)");
        }
        

        com.squareup.okhttp.Call call = getSubscriptionCall(subscriptionId, merchantId, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get Subscription by Subscription ID
     * Gets details of a subscription.
     * @param subscriptionId Subscription ID (required)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @return SubscriptionResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public SubscriptionResponse getSubscription(Long subscriptionId, Long merchantId) throws ApiException {
        ApiResponse<SubscriptionResponse> resp = getSubscriptionWithHttpInfo(subscriptionId, merchantId);
        return resp.getData();
    }

    /**
     * Get Subscription by Subscription ID
     * Gets details of a subscription.
     * @param subscriptionId Subscription ID (required)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @return ApiResponse&lt;SubscriptionResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<SubscriptionResponse> getSubscriptionWithHttpInfo(Long subscriptionId, Long merchantId) throws ApiException {
        com.squareup.okhttp.Call call = getSubscriptionValidateBeforeCall(subscriptionId, merchantId, null, null);
        Type localVarReturnType = new TypeToken<SubscriptionResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Subscription by Subscription ID (asynchronously)
     * Gets details of a subscription.
     * @param subscriptionId Subscription ID (required)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getSubscriptionAsync(Long subscriptionId, Long merchantId, final ApiCallback<SubscriptionResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getSubscriptionValidateBeforeCall(subscriptionId, merchantId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<SubscriptionResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getSubscriptionTransactions
     * @param subscriptionId Subscription ID (required)
     * @param count The number of records in the result. (optional, default to 10)
     * @param orderOn The field on which the results will be sorted on. Refer to the response model for available fields. (optional, default to tran_time)
     * @param orderBy Ascending or Descending Sort order of the result. Possible values are: asc (Ascending sort order), desc (Descending sort order) (optional, default to desc)
     * @param page Zero-based page number, use this to choose a page when there are more results than the count parameter. (optional, default to 0)
     * @param filter Results can be filtered by custom filter criteria. Refer to [Filter](/developer/api/reference#filters) to use the filter parameter. (optional)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getSubscriptionTransactionsCall(Long subscriptionId, Integer count, String orderOn, String orderBy, Integer page, String filter, Long merchantId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/subscription/transactions/{subscription_id}"
            .replaceAll("\\{" + "subscription_id" + "\\}", apiClient.escapeString(subscriptionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (count != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("count", count));
        if (orderOn != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("order_on", orderOn));
        if (orderBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("order_by", orderBy));
        if (page != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
        if (filter != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("filter", filter));
        if (merchantId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("merchant_id", merchantId));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getSubscriptionTransactionsValidateBeforeCall(Long subscriptionId, Integer count, String orderOn, String orderBy, Integer page, String filter, Long merchantId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'subscriptionId' is set
        if (subscriptionId == null) {
            throw new ApiException("Missing the required parameter 'subscriptionId' when calling getSubscriptionTransactions(Async)");
        }
        

        com.squareup.okhttp.Call call = getSubscriptionTransactionsCall(subscriptionId, count, orderOn, orderBy, page, filter, merchantId, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get transactions by Subscription ID
     * Gets all transactions for a subscription. Optional parameters will help filter and restrict the result. 
     * @param subscriptionId Subscription ID (required)
     * @param count The number of records in the result. (optional, default to 10)
     * @param orderOn The field on which the results will be sorted on. Refer to the response model for available fields. (optional, default to tran_time)
     * @param orderBy Ascending or Descending Sort order of the result. Possible values are: asc (Ascending sort order), desc (Descending sort order) (optional, default to desc)
     * @param page Zero-based page number, use this to choose a page when there are more results than the count parameter. (optional, default to 0)
     * @param filter Results can be filtered by custom filter criteria. Refer to [Filter](/developer/api/reference#filters) to use the filter parameter. (optional)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @return TransactionListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public TransactionListResponse getSubscriptionTransactions(Long subscriptionId, Integer count, String orderOn, String orderBy, Integer page, String filter, Long merchantId) throws ApiException {
        ApiResponse<TransactionListResponse> resp = getSubscriptionTransactionsWithHttpInfo(subscriptionId, count, orderOn, orderBy, page, filter, merchantId);
        return resp.getData();
    }

    /**
     * Get transactions by Subscription ID
     * Gets all transactions for a subscription. Optional parameters will help filter and restrict the result. 
     * @param subscriptionId Subscription ID (required)
     * @param count The number of records in the result. (optional, default to 10)
     * @param orderOn The field on which the results will be sorted on. Refer to the response model for available fields. (optional, default to tran_time)
     * @param orderBy Ascending or Descending Sort order of the result. Possible values are: asc (Ascending sort order), desc (Descending sort order) (optional, default to desc)
     * @param page Zero-based page number, use this to choose a page when there are more results than the count parameter. (optional, default to 0)
     * @param filter Results can be filtered by custom filter criteria. Refer to [Filter](/developer/api/reference#filters) to use the filter parameter. (optional)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @return ApiResponse&lt;TransactionListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<TransactionListResponse> getSubscriptionTransactionsWithHttpInfo(Long subscriptionId, Integer count, String orderOn, String orderBy, Integer page, String filter, Long merchantId) throws ApiException {
        com.squareup.okhttp.Call call = getSubscriptionTransactionsValidateBeforeCall(subscriptionId, count, orderOn, orderBy, page, filter, merchantId, null, null);
        Type localVarReturnType = new TypeToken<TransactionListResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get transactions by Subscription ID (asynchronously)
     * Gets all transactions for a subscription. Optional parameters will help filter and restrict the result. 
     * @param subscriptionId Subscription ID (required)
     * @param count The number of records in the result. (optional, default to 10)
     * @param orderOn The field on which the results will be sorted on. Refer to the response model for available fields. (optional, default to tran_time)
     * @param orderBy Ascending or Descending Sort order of the result. Possible values are: asc (Ascending sort order), desc (Descending sort order) (optional, default to desc)
     * @param page Zero-based page number, use this to choose a page when there are more results than the count parameter. (optional, default to 0)
     * @param filter Results can be filtered by custom filter criteria. Refer to [Filter](/developer/api/reference#filters) to use the filter parameter. (optional)
     * @param merchantId Unique ID assigned by Qualpay to a merchant. (optional, default to 0)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getSubscriptionTransactionsAsync(Long subscriptionId, Integer count, String orderOn, String orderBy, Integer page, String filter, Long merchantId, final ApiCallback<TransactionListResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getSubscriptionTransactionsValidateBeforeCall(subscriptionId, count, orderOn, orderBy, page, filter, merchantId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<TransactionListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for pauseSubscription
     * @param subscriptionId  (required)
     * @param body Customer ID (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call pauseSubscriptionCall(Long subscriptionId, PauseSubscriptionRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/subscription/{subscription_id}/pause"
            .replaceAll("\\{" + "subscription_id" + "\\}", apiClient.escapeString(subscriptionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call pauseSubscriptionValidateBeforeCall(Long subscriptionId, PauseSubscriptionRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'subscriptionId' is set
        if (subscriptionId == null) {
            throw new ApiException("Missing the required parameter 'subscriptionId' when calling pauseSubscription(Async)");
        }
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling pauseSubscription(Async)");
        }
        

        com.squareup.okhttp.Call call = pauseSubscriptionCall(subscriptionId, body, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Pause a Subscription
     * Pauses an active subscription. Recurring payments will be skipped when a subscription is paused. Only active subscriptions can be paused. 
     * @param subscriptionId  (required)
     * @param body Customer ID (required)
     * @return SubscriptionResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public SubscriptionResponse pauseSubscription(Long subscriptionId, PauseSubscriptionRequest body) throws ApiException {
        ApiResponse<SubscriptionResponse> resp = pauseSubscriptionWithHttpInfo(subscriptionId, body);
        return resp.getData();
    }

    /**
     * Pause a Subscription
     * Pauses an active subscription. Recurring payments will be skipped when a subscription is paused. Only active subscriptions can be paused. 
     * @param subscriptionId  (required)
     * @param body Customer ID (required)
     * @return ApiResponse&lt;SubscriptionResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<SubscriptionResponse> pauseSubscriptionWithHttpInfo(Long subscriptionId, PauseSubscriptionRequest body) throws ApiException {
        com.squareup.okhttp.Call call = pauseSubscriptionValidateBeforeCall(subscriptionId, body, null, null);
        Type localVarReturnType = new TypeToken<SubscriptionResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Pause a Subscription (asynchronously)
     * Pauses an active subscription. Recurring payments will be skipped when a subscription is paused. Only active subscriptions can be paused. 
     * @param subscriptionId  (required)
     * @param body Customer ID (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call pauseSubscriptionAsync(Long subscriptionId, PauseSubscriptionRequest body, final ApiCallback<SubscriptionResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = pauseSubscriptionValidateBeforeCall(subscriptionId, body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<SubscriptionResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for resumeSubscription
     * @param subscriptionId  (required)
     * @param body Customer ID (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call resumeSubscriptionCall(Long subscriptionId, ResumeSubscriptionRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/subscription/{subscription_id}/resume"
            .replaceAll("\\{" + "subscription_id" + "\\}", apiClient.escapeString(subscriptionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call resumeSubscriptionValidateBeforeCall(Long subscriptionId, ResumeSubscriptionRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'subscriptionId' is set
        if (subscriptionId == null) {
            throw new ApiException("Missing the required parameter 'subscriptionId' when calling resumeSubscription(Async)");
        }
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling resumeSubscription(Async)");
        }
        

        com.squareup.okhttp.Call call = resumeSubscriptionCall(subscriptionId, body, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Resume a Subscription
     * Resumes a suspended or paused subscription. When a suspended subscription is resumed, Qualpay’s subscription engine will initiate all the missed subscription transactions. When a paused subscription is resumed, all missed payments are skipped. 
     * @param subscriptionId  (required)
     * @param body Customer ID (required)
     * @return SubscriptionResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public SubscriptionResponse resumeSubscription(Long subscriptionId, ResumeSubscriptionRequest body) throws ApiException {
        ApiResponse<SubscriptionResponse> resp = resumeSubscriptionWithHttpInfo(subscriptionId, body);
        return resp.getData();
    }

    /**
     * Resume a Subscription
     * Resumes a suspended or paused subscription. When a suspended subscription is resumed, Qualpay’s subscription engine will initiate all the missed subscription transactions. When a paused subscription is resumed, all missed payments are skipped. 
     * @param subscriptionId  (required)
     * @param body Customer ID (required)
     * @return ApiResponse&lt;SubscriptionResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<SubscriptionResponse> resumeSubscriptionWithHttpInfo(Long subscriptionId, ResumeSubscriptionRequest body) throws ApiException {
        com.squareup.okhttp.Call call = resumeSubscriptionValidateBeforeCall(subscriptionId, body, null, null);
        Type localVarReturnType = new TypeToken<SubscriptionResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Resume a Subscription (asynchronously)
     * Resumes a suspended or paused subscription. When a suspended subscription is resumed, Qualpay’s subscription engine will initiate all the missed subscription transactions. When a paused subscription is resumed, all missed payments are skipped. 
     * @param subscriptionId  (required)
     * @param body Customer ID (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call resumeSubscriptionAsync(Long subscriptionId, ResumeSubscriptionRequest body, final ApiCallback<SubscriptionResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = resumeSubscriptionValidateBeforeCall(subscriptionId, body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<SubscriptionResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for updatePlan
     * @param planCode Plan Code of the plan that will be updated (required)
     * @param body Recurring Plan Object. Send only the fields that require an update. Read only fields will be ignored (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call updatePlanCall(String planCode, UpdateRecurringPlanRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/plan/{plan_code}"
            .replaceAll("\\{" + "plan_code" + "\\}", apiClient.escapeString(planCode.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call updatePlanValidateBeforeCall(String planCode, UpdateRecurringPlanRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'planCode' is set
        if (planCode == null) {
            throw new ApiException("Missing the required parameter 'planCode' when calling updatePlan(Async)");
        }
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling updatePlan(Async)");
        }
        

        com.squareup.okhttp.Call call = updatePlanCall(planCode, body, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Update a Recurring Plan
     * Update an active recurring plan. Only the fields sent in the request body will be updated. Only an active plan can be updated. If there are subscribers to this plan, then this plan will be archived and a copy of the plan with a new plan_id will be generated. All updates will be made on the new plan. Save the new plan_id to manage a plan
     * @param planCode Plan Code of the plan that will be updated (required)
     * @param body Recurring Plan Object. Send only the fields that require an update. Read only fields will be ignored (required)
     * @return RecurringPlanResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public RecurringPlanResponse updatePlan(String planCode, UpdateRecurringPlanRequest body) throws ApiException {
        ApiResponse<RecurringPlanResponse> resp = updatePlanWithHttpInfo(planCode, body);
        return resp.getData();
    }

    /**
     * Update a Recurring Plan
     * Update an active recurring plan. Only the fields sent in the request body will be updated. Only an active plan can be updated. If there are subscribers to this plan, then this plan will be archived and a copy of the plan with a new plan_id will be generated. All updates will be made on the new plan. Save the new plan_id to manage a plan
     * @param planCode Plan Code of the plan that will be updated (required)
     * @param body Recurring Plan Object. Send only the fields that require an update. Read only fields will be ignored (required)
     * @return ApiResponse&lt;RecurringPlanResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<RecurringPlanResponse> updatePlanWithHttpInfo(String planCode, UpdateRecurringPlanRequest body) throws ApiException {
        com.squareup.okhttp.Call call = updatePlanValidateBeforeCall(planCode, body, null, null);
        Type localVarReturnType = new TypeToken<RecurringPlanResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Update a Recurring Plan (asynchronously)
     * Update an active recurring plan. Only the fields sent in the request body will be updated. Only an active plan can be updated. If there are subscribers to this plan, then this plan will be archived and a copy of the plan with a new plan_id will be generated. All updates will be made on the new plan. Save the new plan_id to manage a plan
     * @param planCode Plan Code of the plan that will be updated (required)
     * @param body Recurring Plan Object. Send only the fields that require an update. Read only fields will be ignored (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call updatePlanAsync(String planCode, UpdateRecurringPlanRequest body, final ApiCallback<RecurringPlanResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = updatePlanValidateBeforeCall(planCode, body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<RecurringPlanResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for updateSubscription
     * @param subscriptionId  (required)
     * @param body Subscription Request (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call updateSubscriptionCall(Long subscriptionId, UpdateSubscriptionRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/subscription/{subscription_id}"
            .replaceAll("\\{" + "subscription_id" + "\\}", apiClient.escapeString(subscriptionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call updateSubscriptionValidateBeforeCall(Long subscriptionId, UpdateSubscriptionRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'subscriptionId' is set
        if (subscriptionId == null) {
            throw new ApiException("Missing the required parameter 'subscriptionId' when calling updateSubscription(Async)");
        }
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling updateSubscription(Async)");
        }
        

        com.squareup.okhttp.Call call = updateSubscriptionCall(subscriptionId, body, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Update a Subscription
     * Updates the start date of an existing subscription. Only subscriptions that has not yet started can be updated. Only start date can be updated. 
     * @param subscriptionId  (required)
     * @param body Subscription Request (required)
     * @return SubscriptionResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public SubscriptionResponse updateSubscription(Long subscriptionId, UpdateSubscriptionRequest body) throws ApiException {
        ApiResponse<SubscriptionResponse> resp = updateSubscriptionWithHttpInfo(subscriptionId, body);
        return resp.getData();
    }

    /**
     * Update a Subscription
     * Updates the start date of an existing subscription. Only subscriptions that has not yet started can be updated. Only start date can be updated. 
     * @param subscriptionId  (required)
     * @param body Subscription Request (required)
     * @return ApiResponse&lt;SubscriptionResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<SubscriptionResponse> updateSubscriptionWithHttpInfo(Long subscriptionId, UpdateSubscriptionRequest body) throws ApiException {
        com.squareup.okhttp.Call call = updateSubscriptionValidateBeforeCall(subscriptionId, body, null, null);
        Type localVarReturnType = new TypeToken<SubscriptionResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Update a Subscription (asynchronously)
     * Updates the start date of an existing subscription. Only subscriptions that has not yet started can be updated. Only start date can be updated. 
     * @param subscriptionId  (required)
     * @param body Subscription Request (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call updateSubscriptionAsync(Long subscriptionId, UpdateSubscriptionRequest body, final ApiCallback<SubscriptionResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = updateSubscriptionValidateBeforeCall(subscriptionId, body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<SubscriptionResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
